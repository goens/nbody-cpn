#include <sys/types.h>
#include <sys/stat.h>
#include <unistd.h>

#include <string.h>
#include <stdio.h>
#include <stdlib.h>
#include <math.h>

/* #include <gsl/gsl_cblas.h> */

#include "nbody.h"

/*
 * DATASET:
 * Dubinksi 1995 : The file dubinski.tab.gz contains a simple (free format) table of 7 columns and 81920 rows:
 * the masses and six phase space coordinates (x,y,z,vx,vy,vz) of 81920 particles that define the initial conditions
 * for a MW/Andromeda collision. 
 * Contact John Dubinski (dubinski@cita.utoronto.ca) for more details 
 * (see also: Dubinski, Mihos & Hernquist, 1996, ApJ, 462, 576). Its the model B collision discussed in this paper). 

 * \delta t = 0.1, this corresponds to 1.8e6 years when scaled to physical units for the galaxy
 * Plummer softening radius \epsilon = 0.025 (80pc) 
 */


/*
 * This is a Runge-Kutta step
 * For a given function f, it takes:
 *   - the time (or in general, ODE variable) t
 *   - the (current) solution vector (approximation) y
 *   - the step length for the next step h
 *
 */

/* inline seems to be unsupported? */
/*because of the fp I can't make this guy into a process, so I'll inline it */

octree_node_t * octree_generate_tree(long N, particle_t *particles, rvector_t center, real_t length){
    octree_node_t *tree = calloc(1,sizeof(octree_node_t));
    long i;
    int l;
    for(i=0;i<N;i++){
        for(l = 0; l <3;l++){
            if( abs(center.x[l] - particles[i].pos[l]) > length){
                printf("Error, particle does not fit into domain (center: %ld %ld %ld, length %ld, particle: ", center.x[0],center.x[1],center.x[2],length);
                particle_pretty_print(particles + i);
                printf(")\n");
                exit(1);
            }
        }
        octree_insert_node(particles + i, tree, center, length);
    }
    return tree;
}

void octree_insert_node(particle_t *particle, octree_node_t *tree, rvector_t center,real_t length){
    int j;
    if(length == 0){
	printf("error, tried to insert a particle into a volumeless cube\n");
	exit(1);
	}


    if(tree->particle == NULL){ /* unocupied octant */
        tree->particle = particle;
    }
    else{
        if(tree->children == NULL){ /* ocupied octant, leaf: repartition */
            tree->children = calloc(8,sizeof(octree_node_t));
            for(j=0;j<8;j++){
                tree->children[j].paren = tree;
                tree->children[j].length = length; /* full length of octant is double the distance from center to edge */
            }

            /*        --------------                 */
            /*      / |  3  |  7  /|                 */
            /*     /  -----------/--                 */
            /*    /   |  2  |  6/  |                 */
            /*   /   ----------/---   z              */
            /*   --------------   /    ^  ^y         */
            /*   |  1  |  5   |  /     | /           */
            /*   -------------- /      |/            */
            /*   |  0  |  4   |/        --> x        */
            /*   --------------                      */

            /* decide which octant:                  */
            real_t new_length = length / 2.;
            /* printf("length = %lf; new length = %lf\n", length, new_length); */
            int octant_index = 4*(particle->pos[0] < center.x[0]) + 2*(particle->pos[1] < center.x[1]) + (particle->pos[2] < center.x[2]);
            rvector_t new_center;
            for(j=0;j<3;j++){
                /* printf(" {delta = (%lf - %lf)*%lf}", (real_t)(particle->pos[j] < center.x[j]), 1/2. , new_length); */
                new_center.x[j] = center.x[j] + ((real_t)(particle->pos[j] > center.x[j]) - 1/2.) * new_length;
                /* printf(" %lf ",new_center.x[j]); */
            }
            /* printf("\n"); */

            octree_insert_node(particle,&(tree->children[octant_index]),new_center,new_length);

            /* /\* check that particles are not the exactly at the same position *\/ */
            /* /\* this is going to be a problem with cpn, better move it to the nbody step *\/ */
            /* int equal = 1; */
            /* for(j=0;j<3;j++){ */
            /*     equal = equal && (tree->particle->pos[j] == particle->pos[j]); */
            /* } */
            /* if(equal){ */
            /*     for(j=0;j<3;j++){ */
            /*         tree->particle->pos[j] += soft_eps; */
            /*         particle->pos[j] -= soft_eps; */
            /*     } */
            /* } */
                

            /* also for the existing particle */
            octant_index = 4*(tree->particle->pos[0] < center.x[0]) + 2*(tree->particle->pos[1] < center.x[1]) + (tree->particle->pos[2] < center.x[2]);
            /* printf("new center for p = ["); */
            /* particle_pretty_print(tree->particle); */
            /* printf("] = "); */
            for(j=0;j<3;j++){
                new_center.x[j] = center.x[j] + ((real_t)(tree->particle->pos[j] > center.x[j]) - 1/2.) * new_length;
                /* printf(" %lf ",new_center.x[j]); */
            }
            /* printf("\n"); */

            octree_insert_node(tree->particle,&(tree->children[octant_index]),new_center,new_length);

            /* create a center of mass particle */
            particle_t * center_of_mass = malloc(sizeof(particle_t));
            center_of_mass->mass = particle->mass + tree->particle->mass;
            for(j=0;j<3;j++){
                center_of_mass->pos[j] = (particle-> mass * particle->pos[j] + tree->particle->mass * tree->particle->pos[j])/center_of_mass->mass;
                center_of_mass->vel[j] = 0; /* init, but this value has no meaning */
            }
            tree->particle = center_of_mass;
        }
        else{ /* tree has children, just update center of mass */
            for(j=0;j<3;j++){
                tree->particle->pos[j] = (tree->particle->mass * tree->particle->pos[j] + particle->mass*particle->pos[j])/ (tree->particle->mass + particle->mass) ;
            }
            tree->particle->mass += particle->mass;

            /* insert in subtree */
            real_t new_length = length / 2.;
            int octant_index = 4*(particle->pos[0] < center.x[0]) + 2*(particle->pos[1] < center.x[1]) + (particle->pos[2] < center.x[2]);
            rvector_t new_center;
            for(j=0;j<3;j++){
                new_center.x[j] = center.x[j] + ((particle->pos[j] > center.x[j]) - 1/2.) * new_length;
            }
            octree_insert_node(particle,&(tree->children[octant_index]),new_center,new_length);
        }

    }
}

void octree_free(octree_node_t *tree){
    int j;
    if(tree == NULL) return;

    if(tree->particle != NULL && tree->children != NULL){ 
        /* particle is a center of mass particle, free it */
        free(tree->particle);
        tree->particle = NULL;
    }

    if(tree->children != NULL){
        for(j=0;j<8;j++){
            octree_free(tree->children+j);
        }
        free(tree->children);
        tree->children=NULL;
    }

    /* free root node */
    if(tree->paren == NULL) free(tree);
}

void octree_pretty_print(octree_node_t *tree){
    int j = 0;

    if( tree == NULL ) return;
    printf(" (");
    if( tree->particle != NULL){
        printf(" [");
        particle_pretty_print(tree->particle);
        printf("] ");
    }
    if(tree->children != NULL){
        for(j=0;j<8;j++){
            octree_pretty_print(&(tree->children[j]));
        }
    }
    printf(")");

}

void nbody_add_particle_particle_interaction(particle_t *particle_i, particle_t *particle_j, rvector_t *res){
    real_t norm;
    int l;
	 real_t soft_eps_sq = soft_eps * soft_eps; 
    const int n = 6;
    norm = 0;
    for(l = 0; l<n/2;l++){
        norm += pow(particle_j->pos[l]-particle_i->pos[l],2);
        if(norm < soft_eps_sq) /* minimal distance to avoid numeric errors! */
            norm = soft_eps_sq;
    }
    norm = pow(norm,3./2.);
    for(l =0; l<n/2; l++){
        res->x[l] = (particle_j->mass * G_const/norm * (particle_j->pos[l]-particle_i->pos[l]));
    }
}

rvector_t nbody_bh_calculate_force(particle_t *particle, octree_node_t *tree){
    rvector_t f = {0., 0., 0.};
    int i,l;
    const int n = 6;

    if(tree->particle == NULL)
        return f;

    if(tree->children == NULL){ /* external node */
        if(tree->particle == particle){
            return f; /*  no interaction with itself */
        }
        else{ /* calculate particle-particle interaction */
            nbody_add_particle_particle_interaction(tree->particle,particle,&f);
        }
    }
    else{ /* not external node. see it it should be considered more */
        real_t ratio = tree->length;
        real_t diff = 0;
        for(l=0;l<n/2;l++)
            diff += pow( tree->particle->pos[l] - particle->pos[l], 2);
        ratio = ratio / sqrt(diff);

        if(ratio < theta){ /* sufficiently far away, approximate with center of mass */
            nbody_add_particle_particle_interaction(tree->particle,particle,&f);
        }
        else{ /* not far away enough, add the component from all children */
            for(i=0;i<8;i++){
                rvector_t temp;
                temp = nbody_bh_calculate_force(particle,tree->children + i);
                for(l=0;l<3;l++){
                    f.x[l] += temp.x[l];

                }
            }
        }

    }
    return f;
}

void particle_pretty_print(particle_t *particle){
    printf("%lf %lf %lf %lf %lf %lf %lf", particle->mass, particle->pos[0], particle->pos[1], particle->pos[2],particle->vel[0],particle->vel[1],particle->vel[2]);
}


__PNkpn Read_file __PNin (char filename[50])
	 __PNout( real_t mass, real_t y_zero[6], long N){

	 FILE *fp;
	 particle_t part; 
	 long i = 0;


	 __PNin(filename){
		  fp = fopen(filename,"r");
		  if(fp == NULL){
				printf("An error ocurred while reading the file: %s\n", filename);
		  }
	 }

	 __PNout(N){ 
		  /* a bit inefficient: determine the number of lines first for allocation */
		  while(!feof(fp))
		  {
				char ch = fgetc(fp);
				if(ch == '\n')
				{
					 N++;
				}
		  }
		  rewind(fp);
	 }

	 i = 7;
	 while(i == 7){
		  i = fscanf(fp, "%lf %lf %lf %lf %lf %lf %lf\n", &(part.mass), &(part.pos[0]), &(part.pos[1]), &(part.pos[2]), &(part.vel[0]), &(part.vel[0]), &(part.vel[0]));  
		  __PNout(mass){
				mass = part.mass;
		  }

		  __PNout(y_zero){
				int l;
				for(l=0;l<3;l++){
					 y_zero[l] = part.pos[l];
					 y_zero[l+3] = part.vel[l];
				}
				/* printf("x{%lf} ", part.pos[0]); */
		  }
	 }
}

/* hard coded array sizes. K for the biggest RK we might include */
__PNkpn RKStep __PNin( real_t t_chan, real_t h_chan, real_t f_t_y1[6], real_t f_t_y2[6], real_t f_t_y3[6], real_t f_t_y4[6], long N_chan, real_t y[6], real_t y_copy[6], real_t y_copy2[6], real_t y_copy3[6], real_t y_copy4[6])
	 __PNout( real_t t_fn1, real_t t_fn2, real_t t_fn3, real_t t_fn4, real_t y_fn1[6],  real_t y_fn2[6],  real_t y_fn3[6],  real_t y_fn4[6], real_t y_tilde[6], real_t t_tilde, real_t h_tilde){
	 /* __PNparam(rk_init_function_t rk_init ) */ /* TODO: make it really parametric for different rk methods */
  
	 long i,j,l;
	 /* indices for: 
		 i: equations (particles)
		 l: equations (components)
		 j: RK Butcher-Tableau
	 */

	 /*initialize with the maximal lengths from the different methods */
	 int m = 4;
	 const int n = 6; //components (2*dimensions)
	 long N;
	 real_t t,h;
	 __PNin(N_chan){ N = N_chan;}
  
	 /* Butcher Tableau */
	 int len_Alpha, len_Gamma, len_Beta, height_Beta;
	 real_t Alpha[m];
	 real_t Gamma[m];
	 real_t Beta[m*m];
	 set_rk4(&len_Alpha, Alpha, &len_Beta, &height_Beta, Beta, &len_Gamma, Gamma);
	 m = len_Alpha;
	 long k;

	 /* adaptive step parameters */
	 /* rvector_t *e; */
	 /* real_t eps2,c; */

	 /* do{ */
	 
	 while(1){

		  /* init step */ 
		  real_t sum[6];

		  __PNin(t_chan, h_chan){
				t = t_chan;
				h = h_chan;
		  }
		  /* here there's probably something fishy! */

		  real_t K[m][6];

		  /* execute the ODE function m times */
		  /* for(j=0;j<m;j++){ */ 
		  /* unroll loop by hand because I can't get it with cpn idiomatically */

		  j = 0; 
		  for(i=0;i<N;i++){ /* this should be divided when having multiple workers! */
				__PNin(y) __PNout(y_fn1){ 
					 for(l=0;l<n;l++){
						  y_fn1[l] = y[l];
					 }

					 /* update the arguments to calculate the next K[j] */
					 for(l=0;l<n;l++){
						  sum[l] = 0;
						  for(k=0;k<j;k++){
								sum[l]+= Beta[j*m+k]*K[k][l];
						  }
						  /* ynew[l] += h * sum[l] */
						  /* cblas_daxpy(n,h,&sum[l],1,&ynew[l],1); */
						  y_fn1[l] += h * sum[l];
					 }

					 __PNout(t_fn1){
						  t_fn1 = t + Alpha[j] * h;
					 }
				}
		  }
		  for(i=0;i<N;i++){ /* this should be divided when having multiple workers! */
				__PNin(f_t_y1){
					 for(l=0;l<6;l++){
						  K[j][l] = f_t_y1[l];
					 }
				}
		  }

		  /* printf("finished. K[%ld][0] = %lf\n",j,K[j][0]); */
		  /* K[j] = (*f)(t + Alpha[j] * h, ynew + (h * sum)); */

		  j = 1;
				for(i=0;i<N;i++){ /* this should be divided when having multiple workers! */
					 __PNin(y_copy) __PNout(y_fn2){ /* here's the deadlock! (reading y for j=1*/
						  for(l=0;l<n;l++){
								y_fn2[l] = y_copy[l];
						  }

						  /* update the arguments to calculate the next K[j] */
						  for(l=0;l<n;l++){
								sum[l] = 0;
								for(k=0;k<j;k++){
									 sum[l]+= Beta[j*m+k]*K[k][l];
								}
								/* ynew[l] += h * sum[l] */
								/* cblas_daxpy(n,h,&sum[l],1,&ynew[l],1); */
								y_fn2[l] += h * sum[l];
						  }
						  __PNout(t_fn2){
						  t_fn2 = t + Alpha[j] * h;
						  }
					 }
				}
		  for(i=0;i<N;i++){ /* this should be divided when having multiple workers! */
				__PNin(f_t_y2){
					 for(l=0;l<6;l++){
						  K[j][l] = f_t_y2[l];
					 }
				}
		  }

		  /* printf("finished. K[%ld][0] = %lf\n",j,K[j][0]); */
		  /* K[j] = (*f)(t + Alpha[j] * h, ynew + (h * sum)); */

		  j = 2;
				for(i=0;i<N;i++){ /* this should be divided when having multiple workers! */
					 __PNin(y_copy2) __PNout(y_fn3){ /* here's the deadlock! (reading y for j=1*/
						  for(l=0;l<n;l++){
								y_fn3[l] = y_copy2[l];
						  }

						  /* update the arguments to calculate the next K[j] */
						  for(l=0;l<n;l++){
								sum[l] = 0;
								for(k=0;k<j;k++){
									 sum[l]+= Beta[j*m+k]*K[k][l];
								}
								/* ynew[l] += h * sum[l] */
								/* cblas_daxpy(n,h,&sum[l],1,&ynew[l],1); */
								y_fn3[l] += h * sum[l];
						  }
						  __PNout(t_fn3){
								t_fn3 = t + Alpha[j] * h;
						  }
					 }
				}
		  for(i=0;i<N;i++){ /* this should be divided when having multiple workers! */
				__PNin(f_t_y3){
					 for(l=0;l<6;l++){
						  K[j][l] = f_t_y3[l];
					 }
				}
		  }

		  /* printf("finished. K[%ld][0] = %lf\n",j,K[j][0]); */
		  /* K[j] = (*f)(t + Alpha[j] * h, ynew + (h * sum)); */

		  j = 3;
				for(i=0;i<N;i++){ /* this should be divided when having multiple workers! */
					 __PNin(y_copy3) __PNout(y_fn4){ /* here's the deadlock! (reading y for j=1*/
						  for(l=0;l<n;l++){
								y_fn4[l] = y_copy3[l];
						  }

						  /* update the arguments to calculate the next K[j] */
						  for(l=0;l<n;l++){
								sum[l] = 0;
								for(k=0;k<j;k++){
									 sum[l]+= Beta[j*m+k]*K[k][l];
								}
								/* ynew[l] += h * sum[l] */
								/* cblas_daxpy(n,h,&sum[l],1,&ynew[l],1); */
								y_fn4[l] += h * sum[l];
						  }
						  __PNout(t_fn4){
								t_fn4 = t + Alpha[j] * h;
						  }
					 }
				}
		  for(i=0;i<N;i++){ /* this should be divided when having multiple workers! */
				__PNin(f_t_y4){
					 for(l=0;l<6;l++){
						  K[j][l] = f_t_y4[l];
					 }
				}
		  }

		  /* printf("finished. K[%ld][0] = %lf\n",j,K[j][0]); */
		  /* K[j] = (*f)(t + Alpha[j] * h, ynew + (h * sum)); */

		  /* }  */ /* end unrolled loop */


		  __PNout(t_tilde, h_tilde){
				for(i=0;i<N;i++){ /* this should be divided when having multiple workers! */
					 __PNin(y_copy4) __PNout(y_tilde){
						  for(l=0;l<n;l++){
								sum[l] = 0;

								for(j=0;j<m;j++){
									 /* if(i==0) */
									 /*     printf("sum[%ld] = %lf*%lf\n",l,Gamma[j],K[j][l]); */
									 sum[l]+=Gamma[j]*K[j][l]; //could rewrite in atlas
								}

								y_tilde[l] = y_copy4[l] + h*sum[l]; //atlas?
								/* if(i==0) */
								/*     printf("ynew[%ld] = %lf + %lf*%lf\n",l,y[l],h,sum[l]); */
						  }
						  t_tilde = t + h;
						  h_tilde = h; /* non-adaptive */
					 }
				}
		  }
		  /* error estimation (for the adaptive version) */

		  /* for(j=0;j<n;j++) sum[j] = 0; */

		  /* for(j=0;j<m;j++){ */
		  /* 	  sum+=Delta(j)*K(j); //atlas */
		  /* } */
		  /* e = h*sum; */
		  /* eps2 = e.NormMax(); //atlas? */
		  /* //cout << "eps = " << eps << " eps2 = " << eps2;   */
		  /* c = (real)0.9 * powl(eps/eps2  ,(1./(1.+Order))); */
		  /* t = t+h; */

		  /* if(eps2>eps){ */
		  /* 	t -= h; */
		  /* } */

		  /* if(c>5) c = 5; */
		  /* if(c<0.1) c = 0.1; */
		  /* h *= c; */
	 
	 
		  /* }while(eps2>eps); */
	 
	 }

}

__PNkpn Nbodyprob __PNin(long N_chan, real_t mass, real_t t, real_t y_chan[6])
	 __PNout(real_t x_chan[6]){
	 long N;
    long i,j,l;
    real_t norm;
	 const real_t soft_eps_sq = soft_eps * soft_eps;
	 
	 __PNin(N_chan){ N = N_chan; }
	 printf("reading masses for nbdoy...");
	 real_t *masses = malloc(N*sizeof(real_t));
	 for(i = 0; i < N; i++){
		  __PNin(mass){
				masses[i] = mass;
		  }
	 }
	 printf("done.\n");
    const int n = 6; /*components (2*dimensions) */
    /* printf("executing nbody function with t = %lf",t); */

	 real_t *x = malloc(N*sizeof(real_t));
	 real_t *y = malloc(N*sizeof(real_t));

	 while(1){ 
		  /*__PNin(y:N) __PNout(x:N){*/ /*I would actually like to do this*/
		  
		  for(i=0;i<N;i++){
				__PNin(y_chan){
					 for(l=0;l<n/2;l++){ /* the first 3 components */
						  y[n*i+l] = y_chan[l];
						  y[n*i+n/2+l] = y_chan[n/2+l];
						  x[n*i+l] = y_chan[n/2+l];  
					 }

				}
				for(l=n*i+n/2;l<n*(i+1);l++) /* the second 3 components (where f will be applied) */
					 x[l] = 0; 
				/* if (i==0) printf( "x = %lf. ", x[0]); */
				for(j=0;j<N;j++){
					 if(i!=j){

						  /* rvector_t diff; */
						  /* for(l = 0;l<n/2;l++) diff[l] =  y[n*j+l]-y[n*i+l]; */
						  /* norm = pow(cblas_dnrm2(3,diff,1),3);  */
						  norm = 0;
						  for(l = 0; l<n/2;l++){
								norm += pow(y[n*j+l]-y[n*i+l],2);
						  }
						  if (norm < soft_eps_sq)
								norm = soft_eps_sq; /* minimal distance for numerical issues */
						  norm = pow(norm,3./2.);

						  for(l=0;l<n/2;l++){
								real_t f_i_j = (masses[j] * G_const/norm * (y[n*j+l] - y[n*i+l]));
								/* if(i==0 && j==1) printf("f_0_1 = %lf * %lf/%lf * (%lf - %lf) =%lf. ",particles[j].mass , G_const,norm , y[n*j+l] , y[n*i+l],f_i_j); */
								x[n*i + n/2 + l] += f_i_j;
						  }
					 }
				}
		  }
		  /* printf("outputing nbody f..."); */
		  for(i=0;i<N;i++){
				__PNout(x_chan){
					 for(l=0;l<n;l++)
						  x_chan[l] = x[n*i+l];
				}
		  }
		  /* printf("f done.\n"); */
		  /* if (i== 0) printf( " (af. int.) x[0] = %lf. ", x[0]); */
	 }
	 free(masses);
	 free(y);
	 free(x);
}


__PNkpn Print_step __PNin(char filename_base_chan[50], long N_chan, real_t mass, real_t t, real_t y[6]){
	 /* setup phase */
	 char filename_base[50];
	 long N;
	 long i;

	 __PNin(filename_base_chan){ strcpy(filename_base,filename_base_chan);}
	 char output_string_base[strlen(filename_base) + 15];
	 char output_string[strlen(filename_base) + 15];
	 strcpy(output_string_base,filename_base);
	 __PNin(N_chan){ N = N_chan;}
	 real_t *masses = malloc(N*sizeof(real_t));
	 struct stat st = {0};

	 if (stat("output", &st) == -1) {
		  mkdir("output", 0700);
	 }

	 for(i = 0; i < N; i++){
		  __PNin(mass){
				masses[i] = mass;
		  }
	 }
	 while(1){
		  __PNin(t){
				char time[15];
				sprintf(time,"_%010.6lf.out",t);
				strcpy(output_string,output_string_base);
				strcat(output_string,time);

				FILE *output_file = fopen(output_string,"w");
				/* printf("printint to file at time t = %lf: \n", t);  */
				for(i=0;i<N;i++){
					 __PNin(y){
					 /* fprintf(output_file,"x = %lf, y = %lf, z = %lf, vx = %lf, vy = %lf, vz = %lf \n",y[6*i+0],y[6*i+1],y[6*i+2],y[6*i+3],y[6*i+4],y[6*i+5]); */
					 fprintf(output_file,"%lf %lf %lf %lf %lf %lf %lf \n",y[0],y[1],y[2],y[3],y[4],y[5],masses[i]);
					 }
				}
				fclose(output_file);
		  }
	 }
	 free(masses);
}

__PNkpn Control __PNin(real_t y_read[6], long N_chan, real_t y_in[6], real_t t_in, real_t h_in) __PNout(char filename[50], char output_filename_base[50], real_t y[6], real_t t_chan, real_t h_chan){

	 /* initalization */
	 char name[] = "data/dubinski_small.tab";
	 char output_file[] = "output/nbody_sim";
	 long N,i;

	 real_t start_t =0, end_t=10, h=0.1;
    real_t t = start_t;
	 int l;

	 /* read particles from file */
	 __PNout(filename){ strcpy(filename,name);}
	 __PNout(output_filename_base){ strcpy(output_filename_base, output_file);}
	 __PNin(N_chan){ N = N_chan;}

	 printf("read a file with %ld particles\n",N);

	 /* solve differential equation */
    printf("Grav. const: %lf\n", G_const);

	 /* send the first batch */
	 __PNout(t_chan,h_chan){
		  t_chan = t;
		  h_chan = h;
	 }
	 printf("starting first RKstep (N = %ld particles)... ", N);
	 for(i=0;i<N;i++){
		  /* printf("{r%ld}!",i); */
		  __PNin(y_read) __PNout(y){
				for(l=0;l<6;l++){
					 y[l] = y_read[l];
				}
				/* printf("w(%ld): x=%lf \n", i, y_read[0]); */
		  }
	 }

	 printf("first rkstep done (scheduled).\n");
	 while(t+h <  end_t){

		  printf("starting RKstep...\n");
		  __PNin(t_in,h_in) __PNout(t_chan,h_chan){
				/* t = t_in; */
				h = h_in;

				if(t+h >= end_t)
					 t = end_t;

				t+= h; /* for the non-adapting version */
				t_chan = t;
				h_chan = h;
		  }
		  /* __PNin(y_in:N) __PNout(y:N,t,h) */
		  for(i=0;i<N;i++){
				__PNin(y_in) __PNout(y){
					 for(l=0;l<6;l++){
						  y[l] = y_in[l];
					 }
				}
		  }
		  printf("RKstep done: t = %lf\n", t); 
	 }
	 exit(0);

	 /* clean up */ 
}

/*********************************/
/*     KPN Topology (Graph)      */
/*********************************/

/*
   a very interesting problem application:
   here, the necessary channel sizes, are 
   very much input dependent! 
*/

__PNchannel real_t y[6], y_read[6], y_fn1[6],y_fn2[6], y_fn3[6],y_fn4[6], f_t_y1[6], f_t_y2[6], f_t_y3[6], f_t_y4[6],y_tilde[6];
__PNchannel real_t mass,t,h,t_fn1,t_fn2,t_fn3,t_fn4,t_tilde, h_tilde;
__PNchannel long n;
__PNchannel char filename[50],output_filename_base[50];

__PNprocess reader = Read_file 
	 __PNin(filename)
	 __PNout(mass,y_read,n);

__PNprocess control = Control 
	 __PNin(y_read,n,y_tilde,t_tilde,h_tilde)
	 __PNout(filename, output_filename_base, y, t, h);

__PNprocess writer = Print_step 
	 __PNin(output_filename_base, n, mass, t_tilde, y_tilde);

/* need 4 nbodies for rk4 */
__PNprocess nbody = Nbodyprob 
	 __PNin(n,mass,t_fn1,y_fn1)
	 __PNout(f_t_y1);
__PNprocess nbody2 = Nbodyprob 
	 __PNin(n,mass,t_fn2,y_fn2)
	 __PNout(f_t_y2);
__PNprocess nbody3 = Nbodyprob 
	 __PNin(n,mass,t_fn3,y_fn3)
	 __PNout(f_t_y3);
__PNprocess nbody4 = Nbodyprob 
	 __PNin(n,mass,t_fn4,y_fn4)
	 __PNout(f_t_y4);

/* here we could do parallel rk steps! (dlp) */
__PNprocess rk = RKStep 
	 __PNin( t, h,f_t_y1, f_t_y2, f_t_y3, f_t_y4,n, y,y,y,y,y)
	 __PNout( t_fn1, t_fn2,t_fn3,t_fn4, y_fn1,y_fn2,y_fn3, y_fn4, y_tilde, t_tilde, h_tilde);

